/// Code generated by {{.PluginName}}. DO NOT EDIT.
use std::sync::Arc;

use axum::extract::{Extension, Path, Query, State};
use axum::Json;
use axum::routing::{{"{"}}{{lower .HTTPMethods}}{{"}"}}
{{if .HasHeaderArguments}}
use axum::http::header::HeaderMap;
{{- end}}
use mikros::{http::ServiceState, errors as merrors};
use serde_derive::{Deserialize, Serialize};
use tonic::Request;

use crate::{{.ModuleName}};{{$moduleName := .ModuleName}}{{$kind := .TemplateKind}}

{{range .WireInputMessages -}}
#[derive(Deserialize)]
pub struct {{.Name}} {
    {{- range .Fields}}
    pub {{.ProtoName}}: {{.TypeByTemplateKind $kind}},
    {{- end}}
}

impl From<{{.Name}}> for {{$moduleName}}::{{.Name}} {
    fn from(m: {{.Name}}) -> Self {
        Self {
        {{- range .Fields}}
            {{.ProtoName}}: m.{{.ProtoName}},
        {{- end}}
        }
    }
}

{{end -}}

{{range .OutboundMessages -}}
#[derive(Serialize)]
pub struct {{.Name}} {
    {{- range .Fields}}
    pub {{.ProtoName}}: {{.TypeByTemplateKind $kind}},
    {{- end}}
}

impl From<{{$moduleName}}::{{.Name}}> for {{.Name}} {
    fn from(m: {{$moduleName}}::{{.Name}}) -> Self {
        Self {
        {{- range .Fields}}
            {{.ProtoName}}: m.{{.ProtoName}},
        {{- end}}
        }
    }
}
{{- end}}

pub struct Router {
    wrapper: Arc<dyn {{.ModuleName}}::{{.ModuleName}}_server::{{.ServiceName}}>,
}

{{range .Methods -}}
{{if .HasBodyArguments -}}
#[derive(Deserialize)]
struct {{.Name}}Body {
    {{- range .BodyArguments}}
    pub {{.ProtoName}}: {{.Field.TypeByTemplateKind $kind}},
    {{- end}}
}
{{end}}
{{if .HasQueryArguments -}}
#[derive(Deserialize)]
struct {{.Name}}Query {
    {{- range .QueryArguments}}
    pub {{.ProtoName}}: {{.Field.TypeByTemplateKind $kind}},
    {{- end}}
}
{{- end}}

pub async fn {{toSnake .Name}}(
    State(state): State<Arc<mikros::Mutex<ServiceState>>>,
    Extension(router): Extension<Router>,
{{- if .HasHeaderArguments}}
    headers: HeaderMap,
{{- end}}
{{- if .HasPathArguments}}
    Path({{.GetPathParameterNames}}): Path<{{.GetPathParameterTypesByTemplateKind $kind}}>,
{{- end}}
{{- if .HasQueryArguments}}
    Query(query): Query<{{.Name}}Query>,
{{- end}}
{{- if .HasBodyArguments}}
    Json(body): Json<{{.Name}}Body>,
{{- end}}
) -> merrors::Result<Json<{{.ResponseName}}>> {
    // Retrieve all arguments to create the endpoint main structure.
    let args = {{.RequestName}} {
        {{- if .HasPathArguments}}
        {{- range .PathArguments}}
        {{.ProtoName}}: {{.ProtoName}},
        {{- end}}
        {{- end}}
        {{- if .HasHeaderArguments}}
        {{- range .HeaderArguments}}
        {{.ProtoName}}: {{.Field.HeaderArgumentByTemplateKind $kind}},
        {{- end}}
        {{- end}}
        {{- if .HasQueryArguments}}
        {{- range .QueryArguments}}
        {{.ProtoName}}: query.{{.ProtoName}},
        {{- end}}
        {{- end}}
        {{- if .HasBodyArguments}}
        {{- range .BodyArguments}}
        {{.ProtoName}}: body.{{.ProtoName}},
        {{- end}}
        {{- end}}
    };

    let input: {{$moduleName}}::{{.Name}} = args.into();
    let mut request = Request::new(input);

    // Adds mikros context inside the request for the wrapper to also access it.
    let context = state.lock().await.context();
    request.extensions_mut().insert(context.clone());

    // TODO: Handle errors properly
    // Translates the wrapper response into the endpoint response.
    let res = router.wrapper.say_hello(request).await.unwrap();
    Ok(Json(res.into_inner().into()))
}
{{- end}}

#[derive(Clone)]
impl Router {
    pub fn new(server: Arc<dyn {{.ModuleName}}::{{.ModuleName}}_server::{{.ServiceName}}>) -> Self {
        Self {
            wrapper: server,
        }
    }

    pub fn routes(self) -> axum::Router<Arc<mikros::Mutex<ServiceState>>> {
        axum::Router::new()
            {{- range .Methods}}
            .route("{{.EndpointByTemplateKind $kind}}", {{lower .HTTPMethod}}({{toSnake .Name}}))
            {{- end}}
            .layer(Extension(self.clone()))
    }
}