// Code generated by {{.PluginName}}. DO NOT EDIT.
package {{.ModuleName}}

{{if .HasImportFor templateName}}
import (
{{- range .GetTemplateImports templateName}}
    {{.Alias}} "{{.Name}}"
{{- end}}
)
{{end}}

{{- if .HasRequiredBody}}
var (
    emptyBodyError = errors.New("cannot handle an empty body")
)
{{- end}}

{{range .Methods}}
func (w *routesWrapper) {{.Name}}(ctx *fasthttp.RequestCtx) {
    requestAttributes := map[string]interface{}{
        "request.endpoint": string(ctx.RequestURI()),
        "request.method": string(ctx.Method()),
    }
    w.Logger.Infof(ctx, "request received", requestAttributes)

    {{if .HasAuthentication}}
    if w.AuthHandler != nil {
        handlers := map[string]interface{}{
            "{{.AuthModeKey}}": {{.AuthModeValue}},
        }

        if err := w.AuthHandler(ctx, handlers); err != nil {
            w.Response.ToError(ctx, err)
            w.Logger.Errorf(ctx, "authentication error")
            return
        }
    }
    {{- end}}

    input, err := w.parse{{.Request.Name}}FromRequest(ctx)
    w.Logger.Debugf(ctx, "request payload details", map[string]interface{}{
        "request.endpoint": string(ctx.RequestURI()),
        "request.method": string(ctx.Method()),
        "request.payload": input,
    })
    if err != nil {
        w.Response.ToError(ctx, err)
        w.Logger.Errorf(ctx, "could not parse request input")
        return
    }

    out, err := w.Handler.{{.Name}}(ctx, input)
    if err != nil {
        w.Response.ToError(ctx, err)
        w.Logger.Errorf(ctx, "internal handler error")
        return
    }

    w.Logger.Infof(ctx, "request successfully handled", requestAttributes)
    w.Response.ToSuccess(ctx, out)
}

{{$request := .Request}}
func (w *routesWrapper) parse{{$request.Name}}FromRequest(ctx *fasthttp.RequestCtx) (*{{$request.Name}}, error) {
    request := &{{$request.DomainName}}{}

    {{- if .HasRequiredBody}}
    if len(ctx.PostBody()) == 0 {
        return nil, emptyBodyError
    }

    if err := json.Unmarshal(ctx.PostBody(), request); err != nil {
        return nil, err
    }
    {{- end}}

    {{range .PathArguments}}
    w.Field.Clear(request.{{.GoName}})
    if v, ok := ctx.UserValue("{{.ProtoName}}").({{.CastType}}); ok {
        request.{{.GoName}} = v
    }
    {{end}}
    {{if .HasQueryArguments}}
    queryArgs := ctx.QueryArgs()
    {{- range .QueryArguments}}
    w.Field.Clear(request.{{.GoName}})
    if v := queryArgs.Peek("{{.ProtoName}}"); v != nil {
        if err := w.Field.Decode(v, &request.{{.GoName}}); err != nil {
            return nil, fmt.Errorf("{{.ProtoName}}@query: %w", err)
        }
    }
    {{end}}
    {{end}}
    {{- range .HeaderArguments}}
    w.Field.Clear(request.{{.GoName}})
    if v := ctx.Request.Header.Peek("{{.ProtoName}}"); v != nil {
        if err := w.Field.Decode(v, &request.{{.GoName}}); err != nil {
            return nil, fmt.Errorf("{{.ProtoName}}@header: %w", err)
        }
    }
    {{- end}}

    return request.IntoWireInput(), nil
}
{{end}}
