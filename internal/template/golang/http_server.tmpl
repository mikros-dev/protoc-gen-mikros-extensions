// Code generated by {{.PluginName}}. DO NOT EDIT.
package {{.ModuleName}}

{{if .HasImportFor templateName}}
import (
{{- range .GetTemplateImports templateName}}
    {{.Alias}} "{{.Name}}"
{{- end}}
)
{{end}}

type HttpServer struct {
    router      *router.Router
    wrapper     *routesWrapper
    response    ResponseForwarder
    field       FieldDecoder
}

type routesWrapper struct {
    Handler     {{.ServiceName}}Server
    AuthHandler AuthHandler
    Logger      Logger
    Response    ResponseForwarder
    Field       FieldDecoder
}

// Logger is the internal server log interface that the service must have
// implemented.
type Logger interface {
	Infof(ctx context.Context, msg string, attrs ...map[string]interface{})
	Errorf(ctx context.Context, msg string, attrs ...map[string]interface{})
	Debugf(ctx context.Context, msg string, attrs ...map[string]interface{})
}

// AuthHandler is the authentication handler supported by mikros, where
// different types of authentication can be implemented by custom plugins.
type AuthHandler func(ctx context.Context, handlers map[string]interface{}) error

// NewHttpServerOptions gathers all available options to create the HTTP server
// object.
type NewHttpServerOptions struct {
    Response    ResponseForwarder
    Field       FieldDecoder
}

// ResponseForwarder is a behavior that the user must implement in order to
// set the way routes will expose their responses.
type ResponseForwarder interface {
    ToError(ctx context.Context, err error)
    ToSuccess(ctx context.Context, out interface{})
}

// FieldDecoder is a behavior that the user must implement in order to parse
// fields from query, path and headers.
type FieldDecoder interface {
    Clear(value interface{})
    Decode(value []byte, out interface{}) error
}

// NewHttpServer creates a new HttpServer object.
func NewHttpServer(options NewHttpServerOptions) *HttpServer {
    return &HttpServer{
        response:   options.Response,
        field:      options.Field,
    }
}

// SetupServer is the implementation of mikros' HttpServer interface.
func (h *HttpServer) SetupServer(
    _ string,
    logger interface{},
    router *router.Router,
    apiHandlers interface{},
    authHandlers func(ctx context.Context, handlers map[string]interface{}) error,
) error {
	handlers, ok := apiHandlers.({{.ServiceName}}Server)
	if !ok {
		return errors.New("cannot convert received handler to the service proper type")
	}

	log, ok := logger.(Logger)
	if !ok {
		return errors.New("could not retrieve internal logger interface")
	}

	h.router = router
	h.wrapper = &routesWrapper{
	    Handler:     handlers,
		Logger:      log,
		AuthHandler: authHandlers,
		Response:    h.response,
		Field:       h.field,
	}

    {{range .Methods}}
    router.Handle("{{.HTTPMethod}}", "{{.Endpoint}}", h.wrapper.{{.Name}})
    {{- range .AdditionalHTTPMethods}}
    router.Router.Handle("{{.Method}}", "{{.Endpoint}}", h.wrapper.{{.Name}})
    {{- end}}
    {{- end}}

	return nil
}

// HttpHandler retrieves a pointer to the internal HTTP server handler
// allowing the caller to couple it at the real server or use it inside
// unit tests.
func (h *HttpServer) HttpHandler() func(*fasthttp.RequestCtx) {
    return h.router.Handler
}
