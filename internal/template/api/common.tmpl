// Code generated by {{.PluginName}}. DO NOT EDIT.
package {{.ModuleName}}

{{if .HasImportFor templateName}}
import (
{{- range .GetTemplateImports templateName}}
    {{.Alias}} "{{.Name}}"
{{- end}}
)
{{end}}

{{- if .OutboundHasBitflagField}}
// currentEnumValues returns all flags enabled from an enum in a string
// format.
func currentEnumValues(flags uint64, values map[int32]string, prefixFilter ...string) []string {
	var flagValues []string

	for k, v := range values {
		if k != 0 {
			bit := uint64(1 << (k - 1))
			if isBitSet(flags, bit) {
				if filter, ok := needsFiltering(prefixFilter...); ok {
					v = strings.TrimPrefix(v, filter)
				}

				flagValues = append(flagValues, v)
			}
		}
	}

	return flagValues
}

func isBitSet(flags, bit uint64) bool {
	return bit&flags != 0
}

func needsFiltering(prefixFilter ...string) (string, bool) {
	if len(prefixFilter) > 0 {
		return prefixFilter[0], true
	}

	return "", false
}
{{- end}}

{{- if .UseCommonConverters}}
// convertToProtobufValue converts an interface{} value into a protobuf.Value
// structure.
func convertToProtobufValue(value interface{}) *structpb.Value {
    switch v := value.(type) {
    case nil:
        return structpb.NewNullValue()
    case string:
        return structpb.NewStringValue(v)
    case int:
        return structpb.NewNumberValue(float64(v))
    case int32:
        return structpb.NewNumberValue(float64(v))
    case int64:
        return structpb.NewNumberValue(float64(v))
    case float32:
        return structpb.NewNumberValue(float64(v))
    case float64:
        return structpb.NewNumberValue(v)
    case bool:
        return structpb.NewBoolValue(v)
    case []interface{}:
        listValue := &structpb.ListValue{}
        for _, item := range v {
            val := convertToProtobufValue(item)
            listValue.Values = append(listValue.Values, val)
        }

        return structpb.NewListValue(listValue)
    case map[string]interface{}:
        structValue := &structpb.Struct{
            Fields: make(map[string]*structpb.Value),
        }

        for key, item := range v {
            val := convertToProtobufValue(item)
            structValue.Fields[key] = val
        }

        return structpb.NewStructValue(structValue)
    }

    return nil
}

func toPtr[T any](x T) *T {
	return &x
}

func protoTimestampToTime(value *ts.Timestamp) time.Time {
	var t time.Time
	if value != nil {
		t = value.AsTime()
	}

	return t
}

func timeToProtoTimestamp(t *time.Time) *ts.Timestamp {
    if t != nil {
    	return ts.New(*t)
    }

    return nil
}

func mapToGrpcStruct(m map[string]interface{}) *structpb.Struct {
	s, _ := structpb.NewStruct(m)
	return s
}
{{- end}}